import React, { useCallback, useState } from 'react';
import {
  View,
  Text,
  ScrollView,
  Image,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Alert,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Event } from '../../../api_schema/types';
import { DisplayTime } from '../utilities/DisplayTime';
import { displayLocaleTimeStringDate } from '../utils/eventUtils';
import { MaterialIcons } from '@expo/vector-icons';
import { EditButton } from '../../common/components/EditButton';
import { DatepickerField } from '../../common/components/DatepickerField';
import EditableField from '../../common/components/EditableField';
import { createEvent } from '../services/eventService';
import EventDateTimeDisplay from './EventDateTimeDisplay';
import { Colors } from '@/constants/Colors';
import useStore from '@/features/common/store/store';
import EventMapField from './EventMapField';

interface CreateEventCardProps {
  onEventCreated?: (event: Event) => void;
  onCancel?: () => void;
  hideButtons?: boolean;
}

const CreateEventCard: React.FC<CreateEventCardProps> = ({
  onEventCreated,
  onCancel,
  hideButtons = false
}) => {
  const { user } = useStore();
  const [editingField, setEditingField] = useState<string | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  // Event data state
  const [eventData, setEventData] = useState<Partial<Event>>({
    name: '',
    description: '',
    locationDescription: '',
    address: '',
    latitude: null,
    longitude: null,
    start: new Date().toISOString(),
    end: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(), // 2 hours later
    imageUrl: '',
    price: 0,
    official: false,
    attending: false,
    bookable: true,
    maxAttendees: null,
  });

  const updateField = useCallback((field: string, value: any) => {
    setEventData(prev => ({ ...prev, [field]: value }));
    setEditingField(null);
  }, []);

  const handleDateChange = useCallback((field: 'start' | 'end') => (date?: Date) => {
    if (date) {
      console.log(`Date changed for ${field}:`, date);
      setEventData(prev => ({ ...prev, [field]: date.toISOString() }));
    }
  }, []);

  const validateAndCreateEvent = async () => {
    // Basic validation
    if (!eventData.name?.trim()) {
      Alert.alert('Error', 'Event name is required');
      return;
    }

    if (!eventData.start) {
      Alert.alert('Error', 'Start date is required');
      return;
    }

    if (eventData.end && new Date(eventData.end) <= new Date(eventData.start)) {
      Alert.alert('Error', 'End date must be after start date');
      return;
    }

    setIsCreating(true);

    try {
      // Create event object with required fields
      const eventToCreate: Event = {
        id: '', // Will be generated by the server
        name: eventData.name,
        description: eventData.description || null,
        locationDescription: eventData.locationDescription || null,
        address: eventData.address || null,
        start: eventData.start,
        end: eventData.end || null,
        imageUrl: eventData.imageUrl || null,
        price: 0,
        official: false, // User-created events are not official
        attending: true,
        bookable: eventData.bookable || true,
        maxAttendees: eventData.maxAttendees || null,
        showAttendees: 'none' as any, // Default value
        cancelled: null,
        bookingStart: null,
        bookingEnd: null,
        locationMarker: null,
        latitude: null,
        longitude: null,
        parentEvent: null,
        admin: [],
        hosts: [],
        tags: [],
        attendees: user ? [{ userId: user.userId }] : [],
        queue: [],
        extras: {},
      };
      console.log('Creating event:', eventToCreate);

      const createdEvent = await createEvent(eventToCreate);
      onEventCreated?.(createdEvent);
    } catch (error) {
      console.error('Error creating event:', error);
      Alert.alert('Error', 'Failed to create event. Please try again.');
    } finally {
      setIsCreating(false);
    }
  };

  const startDate = eventData.start ? new Date(eventData.start) : new Date();
  const endDate = eventData.end ? new Date(eventData.end) : null;

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={90}
      enabled={editingField !== 'dateTime'}
    >
      <ScrollView style={styles.formContainer}>
        <View style={styles.card}>
          {/* Date and Time - Editable */}
          {editingField === 'dateTime' ? (
            <View style={styles.editModeContainer}>
              <Text style={styles.fieldLabel}>Välj datum och tid</Text>
              <DatepickerField
                label="Starttid"
                date={startDate}
                minimumDate={new Date()}
                onDateChange={handleDateChange('start')}
              />
              <DatepickerField
                label="Sluttid"
                date={endDate || undefined}
                minimumDate={startDate}
                onDateChange={handleDateChange('end')}
              />
              <TouchableOpacity
                style={[styles.button, styles.createButton, { marginTop: 12, paddingVertical: 8 }]}
                onPress={() => setEditingField(null)}
              >
                <Text style={[styles.buttonText, { fontSize: 14 }]}>Klar</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <EventDateTimeDisplay
              start={eventData.start || new Date().toISOString()}
              end={eventData.end}
              isEditable={true}
              onEdit={() => setEditingField('dateTime')}
            />
          )}

          {/* Divider after date/time fields */}
          <View style={styles.divider} />


          {/* Image Container - Always shown */}
          {/* <TouchableOpacity
              style={styles.imageContainer}
              onPress={() => setEditingField('imageUrl')}
              activeOpacity={0.8}
            >
              {eventData.imageUrl ? (
                <>
                  <Image
                    style={styles.eventImage}
                    source={{ uri: eventData.imageUrl }}
                    onError={() => {
                      Alert.alert('Invalid Image', 'The provided image URL is not valid');
                      updateField('imageUrl', '');
                    }}
                  />
                </>
              ) : (
                <View style={styles.imagePlaceholder}>
                  <View style={styles.placeholderContent}>
                    <MaterialIcons
                      name="add-photo-alternate"
                      size={48}
                      color={Colors.blueGray600}
                      style={styles.placeholderIcon}
                    />
                    <Text style={styles.placeholderTextMain}>Lägg till bild</Text>
                    <Text style={styles.placeholderTextSub}>Tryck för att lägga till en bild</Text>
                  </View>
                </View>
              )}
            </TouchableOpacity> */}

          {/* Event Name */}

          <EditableField
            label="Event Name"
            value={eventData.name || ''}
            placeholder="Aktivitetens namn *"
            isEditing={editingField === 'name'}
            onEdit={() => setEditingField('name')}
            onSave={(value) => updateField('name', value)}
            style={styles.editableInputHeading}
          />

          {/* Location */}
          <EditableField
            label="Mötesplats"
            value={eventData.locationDescription || ''}
            placeholder="Scandic Elmia, Rum 107"
            isEditing={editingField === 'location'}
            onEdit={() => setEditingField('location')}
            onSave={(value) => updateField('locationDescription', value)}
          />

          {/* Address */}
          <EventMapField
            location={{ address: eventData.address, latitude: eventData.latitude, longitude: eventData.longitude }}
            onLocationChanged={(newLocation) => {
              setEventData(prev => ({
                ...prev,
                address: newLocation.address,
                latitude: newLocation.latitude,
                longitude: newLocation.longitude
              }));
              if ((newLocation.latitude && newLocation.longitude) || !newLocation.address) {
                setEditingField(null);
              }
            }}
            isEditing={editingField === 'address'}
            onEdit={() => setEditingField('address')}
          />

          <EditableField
            label="Max Attendees"
            value={eventData.maxAttendees?.toString() || ''}
            placeholder="Max antal personer"
            isEditing={editingField === 'maxAttendees'}
            onEdit={() => setEditingField('maxAttendees')}
            onSave={(value) => updateField('maxAttendees', value ? parseInt(value) : null)}
            keyboardType="numeric"
          />

          <View style={styles.divider} />

          <EditableField
            label="Description"
            value={eventData.description || ''}
            placeholder="Beskrivning av aktiviteten"
            isEditing={editingField === 'description'}
            onEdit={() => setEditingField('description')}
            onSave={(value) => updateField('description', value)}
            multiline
          />

          {!hideButtons && (
            <View style={styles.buttonContainer}>
              <TouchableOpacity
                style={[styles.button, styles.cancelButton]}
                onPress={onCancel}
                disabled={isCreating}
              >
                <Text style={styles.buttonText}>Avbryt</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.button, styles.createButton]}
                onPress={validateAndCreateEvent}
                disabled={isCreating || !eventData.name?.trim()}
              >
                {isCreating ? (
                  <ActivityIndicator color={Colors.white} />
                ) : (
                  <Text style={styles.buttonText}>Spara</Text>
                )}
              </TouchableOpacity>
            </View>
          )}
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.white,
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  dateText: {
    fontSize: 14,
    fontWeight: 'normal',
    lineHeight: 18,
    marginBottom: 0,
    color: Colors.blueGray500
  },
  eventImage: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 8,
  },
  imageContainer: {
    position: 'relative',
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 8,
    overflow: 'hidden',
  },
  imagePlaceholder: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    backgroundColor: Colors.background50,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: Colors.blueGray200,
    borderStyle: 'dashed',
  },
  placeholderContent: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  placeholderIcon: {
    marginBottom: 8,
  },
  placeholderTextMain: {
    fontSize: 16,
    fontWeight: '500',
    color: Colors.blueGray500,
    marginBottom: 4,
  },
  placeholderTextSub: {
    fontSize: 14,
    color: Colors.blueGray400,
    textAlign: 'center',
  },
  heading: {
    fontSize: 18,
    fontWeight: '600',
    color: '#111827',
  },
  divider: {
    height: 1,
    backgroundColor: Colors.blueGray200,
    marginBottom: 16,
  },
  formContainer: {
    paddingTop: 16,
    flex: 1,
  },
  editableInputHeading: {
    flex: 1,
    fontSize: 18,
    fontWeight: '600',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
    gap: 12,
  },
  button: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    alignItems: 'center',
  },
  createButton: {
    backgroundColor: Colors.teal600,
  },
  cancelButton: {
    backgroundColor: Colors.blueGray500,
  },
  buttonText: {
    color: Colors.white,
    fontSize: 16,
    fontWeight: '600',
  },
  editModeContainer: {
    backgroundColor: Colors.background50,
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
  },
  fieldLabel: {
    fontSize: 12,
    fontWeight: '600',
    color: Colors.blueGray500,
    marginBottom: 4,
  },
});

export default CreateEventCard;