import React, { useCallback, useState } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
  KeyboardAvoidingView,
} from 'react-native';
import { Event } from '../../../api_schema/types';
import { DatepickerField } from '../../common/components/DatepickerField';
import EditableField from '../../common/components/EditableField';
import { createEvent, updateEvent } from '../services/eventService';
import EventDateTimeDisplay from './EventDateTimeDisplay';
import { Colors } from '@/constants/Colors';
import useStore from '@/features/common/store/store';
import EventMapField from './EventMapField';

interface CreateEventCardProps {
  onEventCreated?: (event: Event) => void;
  onEventUpdated?: (event: Event) => void;
  onCancel?: () => void;
  hideButtons?: boolean;
  existingEvent?: Event;
  isInModal?: boolean;
}

const CreateEventCard: React.FC<CreateEventCardProps> = ({
  onEventCreated,
  onEventUpdated,
  onCancel,
  hideButtons = false,
  existingEvent,
  isInModal = false
}) => {
  const { user } = useStore();
  const [editingField, setEditingField] = useState<string | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  // Event data state
  const [eventData, setEventData] = useState<Partial<Event>>(() => {
    if (existingEvent) {
      return {
        name: existingEvent.name || '',
        description: existingEvent.description || '',
        locationDescription: existingEvent.locationDescription || '',
        address: existingEvent.address || '',
        latitude: existingEvent.latitude,
        longitude: existingEvent.longitude,
        start: existingEvent.start || new Date().toISOString(),
        end: existingEvent.end || null,
        imageUrl: existingEvent.imageUrl || '',
        price: existingEvent.price || 0,
        official: existingEvent.official || false,
        attending: existingEvent.attending || false,
        bookable: existingEvent.bookable || true,
        maxAttendees: existingEvent.maxAttendees,
      };
    }
    return {
      name: '',
      description: '',
      locationDescription: '',
      address: '',
      latitude: null,
      longitude: null,
      start: new Date().toISOString(),
      end: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(), // 2 hours later
      imageUrl: '',
      price: 0,
      official: false,
      attending: false,
      bookable: true,
      maxAttendees: null,
    };
  });



  const handleDateChange = useCallback((field: 'start' | 'end') => (date?: Date) => {
    if (date) {
      console.log(`Date changed for ${field}:`, date);
      setEventData(prev => ({ ...prev, [field]: date.toISOString() }));
    }
  }, []);

  const validateAndSaveEvent = async () => {
    // Basic validation
    if (!eventData.name?.trim()) {
      Alert.alert('Error', 'Event name is required');
      return;
    }

    if (!eventData.start) {
      Alert.alert('Error', 'Start date is required');
      return;
    }

    if (eventData.end && new Date(eventData.end) <= new Date(eventData.start)) {
      Alert.alert('Error', 'End date must be after start date');
      return;
    }

    setIsCreating(true);

    try {
      if (existingEvent) {
        // Update existing event
        const eventToUpdate: Event = {
          ...existingEvent,
          name: eventData.name,
          description: eventData.description || null,
          locationDescription: eventData.locationDescription || null,
          address: eventData.address || null,
          start: eventData.start,
          end: eventData.end || null,
          imageUrl: eventData.imageUrl || null,
          maxAttendees: eventData.maxAttendees || null,
          latitude: eventData.latitude,
          longitude: eventData.longitude,
        };
        console.log('Updating event:', eventToUpdate);

        const updatedEvent = await updateEvent(existingEvent.id, eventToUpdate);
        onEventUpdated?.(updatedEvent);
      } else {
        // Create new event
        const eventToCreate: Event = {
          id: '', // Will be generated by the server
          name: eventData.name,
          description: eventData.description || null,
          locationDescription: eventData.locationDescription || null,
          address: eventData.address || null,
          start: eventData.start,
          end: eventData.end || null,
          imageUrl: eventData.imageUrl || null,
          price: 0,
          official: false, // User-created events are not official
          attending: true,
          bookable: eventData.bookable || true,
          maxAttendees: eventData.maxAttendees || null,
          showAttendees: 'none' as any, // Default value
          cancelled: null,
          bookingStart: null,
          bookingEnd: null,
          locationMarker: null,
          latitude: eventData.latitude,
          longitude: eventData.longitude,
          parentEvent: null,
          admin: user ? [user.userId] : [],
          hosts: [],
          tags: [],
          attendees: user ? [{ userId: user.userId }] : [],
          queue: [],
          extras: {},
        };
        console.log('Creating event:', eventToCreate);

        const createdEvent = await createEvent(eventToCreate);
        onEventCreated?.(createdEvent);
      }
    } catch (error) {
      console.error('Error saving event:', error);
      Alert.alert('Error', `Failed to ${existingEvent ? 'update' : 'create'} event. Please try again.`);
    } finally {
      setIsCreating(false);
    }
  };

  const startDate = eventData.start ? new Date(eventData.start) : new Date();
  const endDate = eventData.end ? new Date(eventData.end) : null;

  return isInModal ? (
    <ScrollView style={styles.formContainer}>
      <View style={styles.card}>
        {/* Date and Time - Editable */}
        {editingField === 'dateTime' ? (
          <View style={styles.editModeContainer}>
            <Text style={styles.fieldLabel}>Välj datum och tid</Text>
            <DatepickerField
              label="Starttid"
              date={startDate}
              minimumDate={new Date()}
              onDateChange={handleDateChange('start')}
            />
            <DatepickerField
              label="Sluttid"
              date={endDate || undefined}
              minimumDate={startDate}
              onDateChange={handleDateChange('end')}
            />
            <TouchableOpacity
              style={[styles.button, styles.createButton, { marginTop: 12, paddingVertical: 8 }]}
              onPress={() => setEditingField(null)}
            >
              <Text style={[styles.buttonText, { fontSize: 14 }]}>Klar</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <EventDateTimeDisplay
            start={eventData.start || new Date().toISOString()}
            end={eventData.end}
            isEditable={true}
            onEdit={() => setEditingField('dateTime')}
          />
        )}

        {/* Divider after date/time fields */}
        <View style={styles.divider} />

        {/* Event Name */}

        <EditableField
          label="Event Name"
          value={eventData.name || ''}
          placeholder="Aktivitetens namn *"
          isEditing={editingField === 'name'}
          onEdit={() => setEditingField('name')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, name: value }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, name: value }))}
          style={styles.editableInputHeading}
        />

        {/* Location */}
        <EditableField
          label="Mötesplats"
          value={eventData.locationDescription || ''}
          placeholder="Scandic Elmia, Rum 107"
          isEditing={editingField === 'location'}
          onEdit={() => setEditingField('location')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, locationDescription: value }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, locationDescription: value }))}
        />

        {/* Address */}
        <EventMapField
          location={{ address: eventData.address, latitude: eventData.latitude, longitude: eventData.longitude }}
          onLocationChanged={(newLocation) => {
            setEventData(prev => ({
              ...prev,
              address: newLocation.address,
              latitude: newLocation.latitude,
              longitude: newLocation.longitude
            }));
            if ((newLocation.latitude && newLocation.longitude) || !newLocation.address) {
              setEditingField(null);
            }
          }}
          isEditing={editingField === 'address'}
          onEdit={() => setEditingField('address')}
        />

        <EditableField
          label="Max Attendees"
          value={eventData.maxAttendees?.toString() || ''}
          placeholder="Max antal personer"
          isEditing={editingField === 'maxAttendees'}
          onEdit={() => setEditingField('maxAttendees')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, maxAttendees: value ? parseInt(value) : null }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, maxAttendees: value ? parseInt(value) : null }))}
          keyboardType="numeric"
        />

        <View style={styles.divider} />

        <EditableField
          label="Description"
          value={eventData.description || ''}
          placeholder="Beskrivning av aktiviteten"
          isEditing={editingField === 'description'}
          onEdit={() => setEditingField('description')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, description: value }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, description: value }))}
          multiline
        />

        {!hideButtons && (
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={[styles.button, styles.cancelButton]}
              onPress={onCancel}
              disabled={isCreating}
            >
              <Text style={styles.buttonText}>Avbryt</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.button, styles.createButton]}
              onPress={validateAndSaveEvent}
              disabled={isCreating || !eventData.name?.trim()}
            >
              {isCreating ? (
                <ActivityIndicator color={Colors.white} />
              ) : (
                <Text style={styles.buttonText}>
                  {existingEvent ? 'Uppdatera' : 'Spara'}
                </Text>
              )}
            </TouchableOpacity>
          </View>
        )}
      </View>
    </ScrollView>
  ) : (
    <KeyboardAvoidingView
      behavior={'padding'}
      keyboardVerticalOffset={90}
      enabled={editingField !== 'dateTime'}
      style={{ flex: 1 }}
    >
      <ScrollView style={styles.formContainer}>
        <View style={styles.card}>
          {/* Date and Time - Editable */}
          {editingField === 'dateTime' ? (
            <View style={styles.editModeContainer}>
              <Text style={styles.fieldLabel}>Välj datum och tid</Text>
              <DatepickerField
                label="Starttid"
                date={startDate}
                minimumDate={new Date()}
                onDateChange={handleDateChange('start')}
              />
              <DatepickerField
                label="Sluttid"
                date={endDate || undefined}
                minimumDate={startDate}
                onDateChange={handleDateChange('end')}
              />
              <TouchableOpacity
                style={[styles.button, styles.createButton, { marginTop: 12, paddingVertical: 8 }]}
                onPress={() => setEditingField(null)}
              >
                <Text style={[styles.buttonText, { fontSize: 14 }]}>Klar</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <EventDateTimeDisplay
              start={eventData.start || new Date().toISOString()}
              end={eventData.end}
              isEditable={true}
              onEdit={() => setEditingField('dateTime')}
            />
          )}

          {/* Divider after date/time fields */}
          <View style={styles.divider} />

          {/* Event Name */}

          <EditableField
            label="Event Name"
            value={eventData.name || ''}
            placeholder="Aktivitetens namn *"
            isEditing={editingField === 'name'}
            onEdit={() => setEditingField('name')}
            onSave={(value) => {
              setEventData(prev => ({ ...prev, name: value }));
              setEditingField(null);
            }}
            onValueChange={(value) => setEventData(prev => ({ ...prev, name: value }))}
            style={styles.editableInputHeading}
          />

          {/* Location */}
          <EditableField
            label="Mötesplats"
            value={eventData.locationDescription || ''}
            placeholder="Scandic Elmia, Rum 107"
            isEditing={editingField === 'location'}
            onEdit={() => setEditingField('location')}
            onSave={(value) => {
              setEventData(prev => ({ ...prev, locationDescription: value }));
              setEditingField(null);
            }}
            onValueChange={(value) => setEventData(prev => ({ ...prev, locationDescription: value }))}
          />

          {/* Address */}
          <EventMapField
            location={{ address: eventData.address, latitude: eventData.latitude, longitude: eventData.longitude }}
            onLocationChanged={(newLocation) => {
              setEventData(prev => ({
                ...prev,
                address: newLocation.address,
                latitude: newLocation.latitude,
                longitude: newLocation.longitude
              }));
              if ((newLocation.latitude && newLocation.longitude) || !newLocation.address) {
                setEditingField(null);
              }
            }}
            isEditing={editingField === 'address'}
            onEdit={() => setEditingField('address')}
          />

          <EditableField
            label="Max Attendees"
            value={eventData.maxAttendees?.toString() || ''}
            placeholder="Max antal personer"
            isEditing={editingField === 'maxAttendees'}
            onEdit={() => setEditingField('maxAttendees')}
            onSave={(value) => {
              setEventData(prev => ({ ...prev, maxAttendees: value ? parseInt(value) : null }));
              setEditingField(null);
            }}
            onValueChange={(value) => setEventData(prev => ({ ...prev, maxAttendees: value ? parseInt(value) : null }))}
            keyboardType="numeric"
          />

          <View style={styles.divider} />

          <EditableField
            label="Description"
            value={eventData.description || ''}
            placeholder="Beskrivning av aktiviteten"
            isEditing={editingField === 'description'}
            onEdit={() => setEditingField('description')}
            onSave={(value) => {
              setEventData(prev => ({ ...prev, description: value }));
              setEditingField(null);
            }}
            onValueChange={(value) => setEventData(prev => ({ ...prev, description: value }))}
            multiline
          />

          {!hideButtons && (
            <View style={styles.buttonContainer}>
              <TouchableOpacity
                style={[styles.button, styles.cancelButton]}
                onPress={onCancel}
                disabled={isCreating}
              >
                <Text style={styles.buttonText}>Avbryt</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.button, styles.createButton]}
                onPress={validateAndSaveEvent}
                disabled={isCreating || !eventData.name?.trim()}
              >
                {isCreating ? (
                  <ActivityIndicator color={Colors.white} />
                ) : (
                  <Text style={styles.buttonText}>
                    {existingEvent ? 'Uppdatera' : 'Spara'}
                  </Text>
                )}
              </TouchableOpacity>
            </View>
          )}
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.white,
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },



  divider: {
    height: 1,
    backgroundColor: Colors.blueGray200,
    marginBottom: 16,
  },
  formContainer: {
    paddingTop: 16,
    flex: 1,
  },
  editableInputHeading: {
    flex: 1,
    fontSize: 18,
    fontWeight: '600',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
    gap: 12,
  },
  button: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    alignItems: 'center',
  },
  createButton: {
    backgroundColor: Colors.teal600,
  },
  cancelButton: {
    backgroundColor: Colors.blueGray500,
  },
  buttonText: {
    color: Colors.white,
    fontSize: 16,
    fontWeight: '600',
  },
  editModeContainer: {
    backgroundColor: Colors.background50,
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
  },
  fieldLabel: {
    fontSize: 12,
    fontWeight: '600',
    color: Colors.blueGray500,
    marginBottom: 4,
  },
});

export default CreateEventCard;