import React, { useCallback, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
  KeyboardAvoidingView,
} from 'react-native';
import { Event } from '../../../api_schema/types';
import { DatepickerField } from '../../common/components/DatepickerField';
import EditableField from '../../common/components/EditableField';
import { createEvent, updateEvent } from '../services/eventService';
import EventDateTimeDisplay from './EventDateTimeDisplay';
import { Colors } from '@/constants/Colors';
import useStore from '@/features/common/store/store';
import EventMapField from './EventMapField';
import { eventCardStyles, editableFieldStyles } from '../styles/eventCardStyles';

interface CreateEventCardProps {
  onEventCreated?: (event: Event) => void;
  onEventUpdated?: (event: Event) => void;
  onCancel?: () => void;
  hideButtons?: boolean;
  existingEvent?: Event;
}

const CreateEventCard: React.FC<CreateEventCardProps> = ({
  onEventCreated,
  onEventUpdated,
  onCancel,
  hideButtons = false,
  existingEvent,
}) => {
  const { user } = useStore();
  const [editingField, setEditingField] = useState<string | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  // Event data state
  const [eventData, setEventData] = useState<Partial<Event>>(() => {
    if (existingEvent) {
      return {
        name: existingEvent.name || '',
        description: existingEvent.description || '',
        locationDescription: existingEvent.locationDescription || '',
        address: existingEvent.address || '',
        latitude: existingEvent.latitude,
        longitude: existingEvent.longitude,
        start: existingEvent.start || new Date().toISOString(),
        end: existingEvent.end || null,
        imageUrl: existingEvent.imageUrl || '',
        price: existingEvent.price || 0,
        official: existingEvent.official || false,
        attending: existingEvent.attending || false,
        bookable: existingEvent.bookable || true,
        maxAttendees: existingEvent.maxAttendees,
      };
    }
    return {
      name: '',
      description: '',
      locationDescription: '',
      address: '',
      latitude: null,
      longitude: null,
      start: new Date().toISOString(),
      end: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(), // 2 hours later
      imageUrl: '',
      price: 0,
      official: false,
      attending: false,
      bookable: true,
      maxAttendees: null,
    };
  });



  const handleDateChange = useCallback((field: 'start' | 'end') => (date?: Date) => {
    if (date) {
      console.log(`Date changed for ${field}:`, date);
      setEventData(prev => ({ ...prev, [field]: date.toISOString() }));
    }
  }, []);

  const validateAndSaveEvent = async () => {
    // Basic validation
    if (!eventData.name?.trim()) {
      Alert.alert('Error', 'Event name is required');
      return;
    }

    if (!eventData.start) {
      Alert.alert('Error', 'Start date is required');
      return;
    }

    if (eventData.end && new Date(eventData.end) <= new Date(eventData.start)) {
      Alert.alert('Error', 'End date must be after start date');
      return;
    }

    setIsCreating(true);

    try {
      if (existingEvent) {
        // Update existing event
        const eventToUpdate: Event = {
          ...existingEvent,
          name: eventData.name,
          description: eventData.description || null,
          locationDescription: eventData.locationDescription || null,
          address: eventData.address || null,
          start: eventData.start,
          end: eventData.end || null,
          imageUrl: eventData.imageUrl || null,
          maxAttendees: eventData.maxAttendees || null,
          latitude: eventData.latitude,
          longitude: eventData.longitude,
        };
        console.log('Updating event:', eventToUpdate);

        const updatedEvent = await updateEvent(existingEvent.id, eventToUpdate);
        onEventUpdated?.(updatedEvent);
      } else {
        // Create new event
        const eventToCreate: Event = {
          id: '', // Will be generated by the server
          name: eventData.name,
          description: eventData.description || null,
          locationDescription: eventData.locationDescription || null,
          address: eventData.address || null,
          start: eventData.start,
          end: eventData.end || null,
          imageUrl: eventData.imageUrl || null,
          price: 0,
          official: false, // User-created events are not official
          attending: true,
          bookable: eventData.bookable || true,
          maxAttendees: eventData.maxAttendees || null,
          showAttendees: 'none' as any, // Default value
          cancelled: null,
          bookingStart: null,
          bookingEnd: null,
          locationMarker: null,
          latitude: eventData.latitude,
          longitude: eventData.longitude,
          parentEvent: null,
          admin: user ? [user.userId] : [],
          hosts: [],
          tags: [],
          attendees: user ? [{ userId: user.userId }] : [],
          queue: [],
          extras: {},
        };
        console.log('Creating event:', eventToCreate);

        const createdEvent = await createEvent(eventToCreate);
        onEventCreated?.(createdEvent);
      }
    } catch (error) {
      console.error('Error saving event:', error);
      Alert.alert('Error', `Failed to ${existingEvent ? 'update' : 'create'} event. Please try again.`);
    } finally {
      setIsCreating(false);
    }
  };

  const startDate = eventData.start ? new Date(eventData.start) : new Date();
  const endDate = eventData.end ? new Date(eventData.end) : null;

  return (
    <View>
        {/* Date and Time - Editable */}
        {editingField === 'dateTime' ? (
          <View style={eventCardStyles.editModeContainer}>
            <Text style={eventCardStyles.fieldLabel}>Välj datum och tid</Text>
            <DatepickerField
              label="Starttid"
              date={startDate}
              minimumDate={new Date()}
              onDateChange={handleDateChange('start')}
            />
            <DatepickerField
              label="Sluttid"
              date={endDate || undefined}
              minimumDate={startDate}
              onDateChange={handleDateChange('end')}
            />
            <TouchableOpacity
              style={[eventCardStyles.button, eventCardStyles.createButton, { marginTop: 12, paddingVertical: 8 }]}
              onPress={() => setEditingField(null)}
            >
              <Text style={[eventCardStyles.buttonText, { fontSize: 14 }]}>Klar</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <EventDateTimeDisplay
            start={eventData.start || new Date().toISOString()}
            end={eventData.end}
            isEditable={true}
            onEdit={() => setEditingField('dateTime')}
          />
        )}

        {/* Divider after date/time fields */}
        <View style={eventCardStyles.divider} />

        {/* Event Name */}

        <EditableField
          label="Event Name"
          value={eventData.name || ''}
          placeholder="Aktivitetens namn *"
          isEditing={editingField === 'name'}
          onEdit={() => setEditingField('name')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, name: value }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, name: value }))}
          style={editableFieldStyles.editableInputHeading}
        />

        {/* Location */}
        <EditableField
          label="Mötesplats"
          value={eventData.locationDescription || ''}
          placeholder="Scandic Elmia, Rum 107"
          isEditing={editingField === 'location'}
          onEdit={() => setEditingField('location')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, locationDescription: value }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, locationDescription: value }))}
        />

        {/* Address */}
        <EventMapField
          location={{ address: eventData.address, latitude: eventData.latitude, longitude: eventData.longitude }}
          onLocationChanged={(newLocation) => {
            setEventData(prev => ({
              ...prev,
              address: newLocation.address,
              latitude: newLocation.latitude,
              longitude: newLocation.longitude
            }));
            if ((newLocation.latitude && newLocation.longitude) || !newLocation.address) {
              setEditingField(null);
            }
          }}
          isEditing={editingField === 'address'}
          onEdit={() => setEditingField('address')}
        />

        <EditableField
          label="Max Attendees"
          value={eventData.maxAttendees?.toString() || ''}
          placeholder="Max antal personer"
          isEditing={editingField === 'maxAttendees'}
          onEdit={() => setEditingField('maxAttendees')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, maxAttendees: value ? parseInt(value) : null }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, maxAttendees: value ? parseInt(value) : null }))}
          keyboardType="numeric"
        />

        <View style={eventCardStyles.divider} />

        <EditableField
          label="Description"
          value={eventData.description || ''}
          placeholder="Beskrivning av aktiviteten"
          isEditing={editingField === 'description'}
          onEdit={() => setEditingField('description')}
          onSave={(value) => {
            setEventData(prev => ({ ...prev, description: value }));
            setEditingField(null);
          }}
          onValueChange={(value) => setEventData(prev => ({ ...prev, description: value }))}
          multiline
        />

        {!hideButtons && (
          <View style={eventCardStyles.buttonContainer}>
            <TouchableOpacity
              style={[eventCardStyles.button, eventCardStyles.cancelButton]}
              onPress={onCancel}
              disabled={isCreating}
            >
              <Text style={eventCardStyles.buttonText}>Avbryt</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[eventCardStyles.button, eventCardStyles.createButton]}
              onPress={validateAndSaveEvent}
              disabled={isCreating || !eventData.name?.trim()}
            >
              {isCreating ? (
                <ActivityIndicator color={Colors.white} />
              ) : (
                <Text style={eventCardStyles.buttonText}>
                  {existingEvent ? 'Uppdatera' : 'Spara'}
                </Text>
              )}
            </TouchableOpacity>
          </View>
        )}
    </View>
  )
};

// Styles are now imported from ../styles/eventCardStyles
// Only component-specific styles remain here if any are needed

export default CreateEventCard;